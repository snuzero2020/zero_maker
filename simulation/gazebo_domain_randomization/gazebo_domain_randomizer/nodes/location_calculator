#!/usr/bin/env python
from string import Template
import numpy as np
import rospy
from geometry_msgs.msg import Pose, Point, Quaternion
from std_msgs.msg import Int32
from gazebo_msgs.srv import SpawnModel, SpawnModelRequest
from gazebo_msgs.srv import DeleteModel, DeleteModelRequest
from tf.transformations import quaternion_from_euler
import math
import random
import time
from sensor_msgs.msg import Image, CameraInfo
from gazebo_msgs.msg import ModelStates
from image_geometry import PinholeCameraModel
import cv2
from cv_bridge import CvBridge
from scipy.spatial.transform import Rotation as R
import json
import os

def add_vector(points, origin):
    for point in points:
        point[0] = point[0] + origin.x
        point[1] = point[1] + origin.y
        point[2] = point[2] + origin.z
    return points


def project3dto2d(point, camera_position, camera):
    rospy.loginfo("entering project3dto2d function")
    print(camera_position)
    rospy.loginfo(camera_position)
    r = R.from_quat([camera_position.orientation.x,
                     camera_position.orientation.y,
                     camera_position.orientation.z,
                     camera_position.orientation.w])
    rospy.loginfo("debug1")
    r = r.inv()
    rospy.loginfo("debug2")
    p = [point[0]-camera_position.position.x,
         point[1]-camera_position.position.y,
         point[2]-camera_position.position.z]
    rospy.loginfo("debug3")
    p = r.apply(p)
    rospy.loginfo("debug4")
    x = -p[1]
    y = -p[2]
    z = p[0]
    rospy.loginfo("debug5")
    #print(x,y,z)
    #x = -(point[1] - camera_pose.position.y)
    #y = -(point[2] - camera_pose.position.z)
    #z = point[0] - camera_pose.position.x
    rt = camera.project3dToPixel((x,y,z))
    rospy.loginfo("completed project3dto2d function")
    return [x,y,z], rt


class MarkedImage:  
    def __init__(self):
        self._pub_location = rospy.Publisher('/location_truth', Point, queue_size=1)
        self._pub = rospy.Publisher('/dope_image', Image, queue_size=1)
        self._sub_camera_info = rospy.Subscriber('/dope_camera/color/camera_info',
                                                 CameraInfo, self.callback_camera)
        self._sub_image_raw = rospy.Subscriber('/dope_camera/color/image_raw',
                                                Image, self.callback_image)
        self._sub_model_states = rospy.Subscriber('/gazebo/model_states',
                                                  ModelStates, self.callback_model)
        self._sub_collection_sign = rospy.Subscriber('/collection_sign', Int32, self.callback_sign)
        self._camera = PinholeCameraModel()
        self._image = Image()
        self._objs = []
        self._bridge = CvBridge()
        self._camera_position = Pose()
        self._object_cuboid = [[],[[0.0,0.0,0.086],
                                   [0.069, -0.089, 0.182],
                                   [-0.069,-0.089,0.182],
                                   [-0.069,0.089,0.182],
                                   [0.069,0.089,0.182],
                                   [0.069,-0.089,-0.010],
                                   [-0.069,-0.089,-0.010],
                                   [-0.069,0.089,-0.010],
                                   [0.069,0.089,-0.010]]]
        self._index = 0
        self._offset = 0
        #self._camera_rotation_matrix = camera_rotation_matrix

    def callback_camera(self, msg):
        tmp = list(msg.P)
        tmp[3] = 0
        msg.P = tuple(tmp)
        self._camera.fromCameraInfo(msg)

    def callback_image(self, msg):
        self._image = msg

    def callback_sign(self, msg):
        if msg.data == self._index:
            return
        self._index = msg.data
        img = self._bridge.imgmsg_to_cv2(self._image, "bgr8")
        save_file = {}
        obj_list = []
        for obj in self._objs:
            if not obj['name'][0:3] == 'tar':
                continue
            obj_saver = {}
            obj_saver['class'] = 'turtlebot_burger'
            obj_rotation = R.from_quat([obj['pose'].orientation.x,
                                        obj['pose'].orientation.y,
                                        obj['pose'].orientation.z,
                                        obj['pose'].orientation.w])
            object_type = 'turtlebot3_burger'
            v = self._object_cuboid[1]
            v = obj_rotation.apply(v)
            v = add_vector(v,obj['pose'].position)
            v= v.tolist()
            projected = []
            transformed_points = []
            for point in v:
                p, c = project3dto2d(point,self._camera_position,self._camera)
                transformed_points.append(p)
                projected.append([c[0],c[1]])
            obj_saver['cuboid_centroid'] = (100.0*np.array(transformed_points[0])).tolist()
            obj_saver['location'] = (100.0*np.array(transformed_points[0])).tolist()
            obj_saver['cuboid'] = (100.0*np.array(transformed_points[1:9])).tolist()
            obj_saver['projected_cuboid_centroid'] = projected[0]
            obj_saver['projected_cuboid'] = projected[1:9]
            r1 = R.from_quat([obj['pose'].orientation.x,
                                            obj['pose'].orientation.y,
                                            obj['pose'].orientation.z,
                                            obj['pose'].orientation.w])
            r2 = R.from_quat([self._camera_position.orientation.x,
                     self._camera_position.orientation.y,
                     self._camera_position.orientation.z,
                     self._camera_position.orientation.w])
            r2 = r2.inv()
            r = r2 * r1
            obj_saver['quaternion_xyzw'] = list(r.as_quat())
            obj_list.append(obj_saver)

            rt = Point()
            rt.x = transformed_points[0][0]
            rt.y = transformed_points[0][1]
            rt.z = transformed_points[0][2]
            self._pub_location.publish(rt)
            
        self._pub.publish(self._bridge.cv2_to_imgmsg(img, "bgr8"))
        
    def callback_model(self, msg):
        objs = []
        for i, obj_name in enumerate(msg.name):
            if obj_name == 'ground_plane':
                continue
            elif obj_name == 'dope_camera':
                self._camera_position = msg.pose[i]
                continue
            cur = {}
            cur['name'] = obj_name
            cur['pose'] = msg.pose[i]
            objs.append(cur)
        self._objs = objs


if __name__=="__main__":
    rospy.init_node("marked_image")
    marked_image = MarkedImage()
    rospy.spin()
